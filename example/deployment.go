package example

import (
	"fmt"

	"github.com/Azure/draft/pkg/config"
	"github.com/Azure/draft/pkg/deployments"
	"github.com/Azure/draft/pkg/templatewriter"
	"github.com/Azure/draft/pkg/templatewriter/writers"
	"github.com/Azure/draft/template"
)

// WriteDeploymentFiles generates Deployment Files using Draft, writing to a Draft TemplateWriter. See the corresponding draft.yaml file in templates/deployments/[deployType] for the template inputs.
func WriteDeploymentFiles(w templatewriter.TemplateWriter, deploymentOutputPath string, deployConfig *config.DraftConfig, deploymentType string) error {
	d := deployments.CreateDeploymentsFromEmbedFS(template.Deployments, deploymentOutputPath)

	err := d.CopyDeploymentFiles(deploymentType, deployConfig, w)
	if err != nil {
		return fmt.Errorf("failed to generate manifest: %e", err)
	}
	return nil
}

// WriteDeploymentFilesExample shows how to set up a fileWriter and generate a fileMap using WriteDeploymentFiles
func WriteDeploymentFilesExample() error {
	// Create a file map
	fileMap := make(map[string][]byte)

	// Create a template writer that writes to the file map
	w := writers.FileMapWriter{
		FileMap: fileMap,
	}

	// Select the deployment type to generate the files for (must correspond to a directory in the template/deployments directory)
	deploymentType := "manifests"

	// Create a DraftConfig of inputs to the template (must correspond to the inputs in the template/deployments/<deploymentType>/draft.yaml files)
	deployConfig := &config.DraftConfig{
		Variables: []*config.BuilderVar{
			{
				Name: "PORT",
				Default: &config.BuilderVarDefault{
					Value: "80",
				},
				Description: "the port exposed in the application",
				Value:       "8080",
			},
			{
				Name:        "APPNAME",
				Description: "the name of the application",
				Value:       "example-app",
			},
			{
				Name: "SERVICEPORT",
				Default: &config.BuilderVarDefault{
					ReferenceVar: "PORT",
				},
				Description: "the port the service uses to make the application accessible from outside the cluster",
				Value:       "8080",
			},
			{
				Name: "NAMESPACE",
				Default: &config.BuilderVarDefault{
					Value: "default",
				},
				Description: "the name of the image to use in the deployment",
				Value:       "example-namespace",
			},
			{
				Name: "IMAGENAME",
				Default: &config.BuilderVarDefault{
					IsPromptDisabled: true,
					Value:            "the name of the image to use in the deployment",
				},
				Description: "the name of the image to use in the deployment",
				Value:       "example-image",
			},
			{
				Name: "IMAGETAG",
				Default: &config.BuilderVarDefault{
					IsPromptDisabled: true,
					Value:            "latest",
				},
				Description: "the tag of the image to use in the deployment",
				Value:       "latest",
			},
			{
				Name: "GENERATORLABEL",
				Default: &config.BuilderVarDefault{
					IsPromptDisabled: true,
					Value:            "draft",
				},
				Description: "the label to use to identify the deployment as generated by draft",
			},
		},
	}

	// Set the output path for the deployment files
	outputPath := "./"

	// Write the deployment files
	err := WriteDeploymentFiles(&w, outputPath, deployConfig, deploymentType)
	if err != nil {
		return err
	}

	// Read written files from the file map
	fmt.Printf("Files written in WriteDeploymentFilesExample:\n")
	for filePath, fileContents := range fileMap {
		if fileContents == nil {
			return fmt.Errorf("file contents for %s is nil", filePath)
		}
		fmt.Printf("  %s\n", filePath) // Print the file path
	}

	return nil
}
