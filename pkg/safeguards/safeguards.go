package safeguards

import (
	"context"
	"fmt"
	"os"
	"path"
	"strings"

	"github.com/open-policy-agent/opa/rego"
	"gopkg.in/yaml.v3"
)

// Constants
const ConstraintsDirectory = "./constraints/"
const DeploymentFilePrefix = "./deployment/"

// ConstraintFetcher is the interface used to fetch each safeguards constraint
type ConstraintFetcher interface {
	Fetch() ([]ConstraintFile, map[string]map[string]interface{}, error)
}

// ConstraintFile is our struct implementation of the safeguards constraint YAML
// create a getParameters() method
type ConstraintFile struct {
	Metadata Metadata `yaml:"metadata"`
	Spec     Spec     `yaml:"spec"`
	Name     string
}
type Spec struct {
	Targets []Target `yaml:"targets"`
}
type Target struct {
	Target string   `yaml:"target"`
	Rego   string   `yaml:"rego"`
	Libs   []string `yaml:"libs"`
}
type Metadata struct {
	Name string `yaml:"name"`
}

// ConstraintsBuilderA is the implementation of ConstraintFetcher that reads in constraints from the local fs
type ConstraintsBuilderA struct {
}

// fetchTestDeploymentFile pulls in our test deployment YAML
func fetchDeploymentFile(path string) (map[string]interface{}, error) {
	bs, err := os.ReadFile(path)
	if err != nil {
		// handle error
		return nil, fmt.Errorf("reading deployment: %w", err)
	}

	var deploymentFile map[string]interface{}
	if err := yaml.Unmarshal(bs, &deploymentFile); err != nil {
		// handle error
		return nil, fmt.Errorf("unmarshaling input: %w", err)
	}

	return deploymentFile, nil
}

type Params map[string]interface{}

func buildParams() Params {
	p := Params{
		"allowedUsers": []string{
			"nodeclient",
			"system:serviceaccount:kube-system:aci-connector-linux",
			"system:serviceaccount:kube-system:node-controller",
			"acsService",
			"aksService",
			"system:serviceaccount:kube-system:cloud-node-manager",
		},
		"allowedGroups": []string{
			"system:node",
		},
		"cpuLimit":           "200m",
		"memoryLimit":        "1Gi",
		"excludedContainers": []string{},
		"excludedImages":     []string{},
		"labels": []string{
			"kubernetes.azure.com",
		},
		"allowedContainerImagesRegex": ".*",
		"reservedTaints": []string{
			"CriticalAddonsOnly",
		},
		"requiredProbes": []string{
			"readinessProbe",
			"livenessProbe",
		},
	}

	return p
}

// thbarnes: placeholder for now
func buildUserInfo() map[string]interface{} {
	u := map[string]interface{}{
		"username": "system:serviceaccount:kube-system:replicaset-controller",
		"uid":      "439dea65-3e4e-4fa8-b5f8-8fdc4bc7cf53",
		"groups": []string{
			"system:serviceaccounts",
			"system:serviceaccounts:kube-system",
			"system:authenticated",
		},
	}

	return u
}

// buildInput creates our input JSON when given a deployment file
func buildInput(dfMap map[string]interface{}) map[string]interface{} {
	// thbarnes: this needs to be refined and automated
	// generated by kuberenetes api server -> not necessary for testing
	// would be good to make the input a struct

	input := map[string]interface{}{
		"review": map[string]interface{}{
			"object":   dfMap,
			"userInfo": buildUserInfo(),
		},
		"parameters": buildParams(),
	}
	return input
}

func removeYAMLExtension(s string) string {
	return strings.Split(s, ".yaml")[0]
}

// Option A's method of fetching constraints
// thbarnes: figure out why consts aren't being read into debug instance
// refine the path code
func (cba ConstraintsBuilderA) Fetch() ([]ConstraintFile, map[string]map[string]interface{}, error) {
	var c []ConstraintFile
	var dfMap map[string]map[string]interface{}
	cwd, _ := os.Getwd()
	dirs := []string{cwd, ConstraintsDirectory}
	fullPath := path.Join(dirs[0], dirs[1]) + "/"
	constraintDirs, err := os.ReadDir(fullPath)
	if err != nil {
		return c, dfMap, fmt.Errorf("reading safeguards constraints directory for full list of dirs")
	}

	var constraints []os.DirEntry
	for _, dir := range constraintDirs {
		fullConstraintDir := path.Join(fullPath, dir.Name())
		d, err := os.ReadDir(fullConstraintDir)
		if err != nil {
			return c, dfMap, fmt.Errorf("reading constraint file dir: %s", dir.Name())
		}

		for _, con := range d {
			innerPath := path.Join(fullConstraintDir, con.Name())
			// constraint retrieval
			if !con.IsDir() {
				b, err := os.ReadFile(innerPath)
				if err != nil {
					return c, dfMap, fmt.Errorf("reading constraint file: %s", con.Name())
				}

				var constraintFile ConstraintFile
				if err := yaml.Unmarshal(b, &constraintFile); err != nil {
					return c, dfMap, fmt.Errorf("unmarshaling constraint: %w", err)
				}

				constraintFile.Name = removeYAMLExtension(con.Name())
				c = append(c, constraintFile)
				// test deployment retrieval
			} else {
				dfDir, err := os.ReadDir(innerPath)
				if err != nil {
					return c, dfMap, fmt.Errorf("reading test deployment dir: %w", err)
				}

				for _, dFile := range dfDir {
					df, err := fetchDeploymentFile(path.Join(innerPath, dFile.Name()))
					if err != nil {
						return c, dfMap, fmt.Errorf("fetching test deployment: %w", err)
					}
					dfMap[removeYAMLExtension(dFile.Name())] = df
				}

			}
		}

		constraints = append(constraints, d...)
	}

	for _, con := range constraints {
		fullConstraintDir := path.Join(fullPath, con.Name())
		b, err := os.ReadFile(fullConstraintDir)
		if err != nil {
			return c, dfMap, fmt.Errorf("reading constraint file: %s", con.Name())
		}

		var constraintFile ConstraintFile
		if err := yaml.Unmarshal(b, &constraintFile); err != nil {
			return c, dfMap, fmt.Errorf("unmarshaling constraint: %w", err)
		}

		c = append(c, constraintFile)
	}

	return c, dfMap, nil
}

// sanitizeRegoPolicy removes problematic lines from our rego code for consumption as our rego policy in the evalution step
func sanitizeRegoPolicy(rp string) string {
	lines := strings.Split(rp, "\n")
	var newLines []string
	for _, line := range lines {
		if !strings.Contains(line, "import data.lib.") && !strings.Contains(line, "package lib.") {
			newLines = append(newLines, line)
		}
	}
	return strings.Join(newLines, "\n")
}

// appendLibs appends every lib item from the constraint YAML, separated by newlines
func appendLibs(libs []string) string {
	l := ""
	if len(libs) > 0 {
		for _, lib := range libs {
			l += lib + "\n"
		}
	}

	return l
}

func buildQueryString(name string) string {
	return "x = data." + name + ".violation"
}

func evaluateQuery(ctx context.Context, file ConstraintFile, dfMap map[string]map[string]interface{}) error {
	queryString := buildQueryString(file.Metadata.Name)

	// thbarnes: throw in a check for if length is 0 or >1 and error if so
	l := appendLibs(file.Spec.Targets[0].Libs)
	regoString := file.Spec.Targets[0].Rego
	regoPolicy := sanitizeRegoPolicy(regoString + l)

	r := rego.New(
		rego.Query(queryString),
		rego.Module("main.rego", regoPolicy))

	query, err := r.PrepareForEval(ctx)
	if err != nil {
		return fmt.Errorf("creating rego query: %w", err)
	}

	// our input state
	// build inputs PER CONSTRAINT

	input := buildInput(dfMap[file.Name])

	// thbarnes: investigate if you can make your own `input` struct and pass it into here
	rs, err := query.Eval(ctx, rego.EvalInput(input))
	if err != nil {
		return fmt.Errorf("evaluating query: %w", err)
	}

	fmt.Println("Result:", rs[0].Bindings["x"])

	return nil
}

// ValidateDeployment is what will be called by `draft validate` to validate the user's deployment manifest
// against each safeguards constraint
func ValidateDeployment(df, constraint string) error {
	// thbarnes: ConstraintsBuilderB will eventually take over
	ctx := context.TODO()

	var cf ConstraintFetcher
	cba := ConstraintsBuilderA{}
	cf = cba

	constraintFiles, dfMap, err := cf.Fetch()
	if err != nil {
		return fmt.Errorf("fetching constraints: %w", err)
	}

	// evaluate each rego policy against the deployment file

	// only run the specified constraint
	if constraint != "" {
		var f ConstraintFile
		for _, file := range constraintFiles {
			if constraint == file.Name {
				f = file
			}
		}
		err = evaluateQuery(ctx, f, dfMap)
		if err != nil {
			return fmt.Errorf("evaluating query: %w", err)
		}
		// will run against all constraints with no specified constraint
	} else {
		for _, file := range constraintFiles {
			err = evaluateQuery(ctx, file, dfMap)
			if err != nil {
				return fmt.Errorf("evaluating query: %w", err)
			}
		}
	}

	return nil
}
